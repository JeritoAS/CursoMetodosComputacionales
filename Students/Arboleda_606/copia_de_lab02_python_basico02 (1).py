# -*- coding: utf-8 -*-
"""Copia de Lab02_python_basico02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oNk5ZJVL0S3BJOctcvUctVLwrsugER9c

<a href="https://colab.research.google.com/github/hernansalinas/autogrades/blob/main/Laboratorios_Taller/Lab02_python_basico02.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>


# Laboratorio 02
### Métodos computacionales para físicos  y astrónomos
### Universidad de Antioquia
### Prof: Hernan D. Salinas Jiménez
"""

# Ejecutar esta celda antes de cada laboratorio
!git clone https://github.com/hernansalinas/autogradesMetodosComputacionales.git

# Commented out IPython magic to ensure Python compatibility.
# Ejecutar esta celda antes de cada laboratorio
path="autogradesMetodosComputacionales/Laboratorios_Taller/libs"
pathL="autogradesMetodosComputacionales/Laboratorios_Taller/libs/Lab_02"
# %run -i {path}/libUnitTest.py

"""## Problemas

### Factorial
1. Elaborar un algoritmo e implementar en python, el factorial de un número entero `n` ingresado por el usuario.

1. Si el número es un entero deberá retornal el factorial del número.
2. Si el número es negativo deberá aparecer un mensaje tipo string con el mensaje  "el número no puede ser negativo"

3. Si el número es pertenece a los reales(float) el mensaje será, el número no puede ser real.


     ### Ejemplo de Ejecución
    ```python

    >>> factorial(3)
        6

    >>> factorial(1987123)
        =???
```

"""

def factorial(numero):
    if isinstance(numero, float):
        return 'El número no puede ser real'
    elif numero < 0:
        return 'El número tiene que ser positivo'

    factorial = 1
    for i in range(1, numero + 1):
        factorial *= i

    return factorial

valor = int(input('Ingrese un número entero: '))
f = factorial(valor)
if isinstance(f, str):
    print(f)
else:
    print(f"El factorial de {valor} es {f}")

# Commented out IPython magic to ensure Python compatibility.
# %run -i {pathL}/test01.py

"""### Teoria de números

Los enunciados 2 y 3 se refieren a la siguiente información:

Diseñar un programa en el que entrado  un numero `a`  retorne una variable booleana True or false si cumple que es:

2. [Números defectivo](https://es.wikipedia.org/wiki/Número_defectivo) : la suma de los divisores propios es menor que el número.

  La rutina se deberá llamar números_defectivos



3. [Números abundantes](https://es.wikipedia.org/wiki/Número_abundante): la suma de los divisores es mayor que el número.

  La rutina se deberá llamar números_abundantes



4. [Números semiperfectos](https://es.wikipedia.org/wiki/N%C3%BAmero_semiperfecto) la suma de todos o algunos de los divisores propios es igual al número.

  La rutina se debera llamar numeros_semiperfectos

5. [Números perfectos](https://es.wikipedia.org/wiki/N%C3%BAmero_perfecto) la suma de todos sus divisores propios, excepto el mismo numero, es igual al número.

   La rutina se deberá llamar numeros_perfectos


6. [Números primos](https://es.wikipedia.org/wiki/N%C3%BAmero_primo) el número es divisible unicamente por sí mismo y por 1.
   La rutina se deberá llamar numeros_primos


Problema no obligatorio:

P1. Retornar los 30 primeros números de cada clase
"""

def divisores(n):
    l = []
    for i in range(1, n):
        if n % i == 0:
            l.append(i)
    return l

def numeros_defectivos(n):
    divs = divisores(n)
    suma_divisores = sum(divs)
    if suma_divisores < n:
        return True
    else:
        return False

valor = int(input('Ingrese un número entero: '))
es_defectivos = numeros_defectivos(valor)
print(f'El número {valor} es defectivo: {es_defectivos}')

def divisores(n):
    l = []
    for i in range(1, n):
        if n % i == 0:
            l.append(i)
    return l

def es_perfecto(n):
    divs = divisores(n)
    suma_divisores = sum(divs)
    return suma_divisores == n

def primeros_n_perfectos(p):
    perfectos = []
    i = 1
    while len(perfectos) < p:
        if es_perfecto(i):
            perfectos.append(i)
        i += 1
    return perfectos

p = int(input('Ingrese la cantidad de números perfectos a encontrar: '))
perfectos = primeros_n_perfectos(p)
print(f'Los primeros {p} números perfectos son: {perfectos}')

# Commented out IPython magic to ensure Python compatibility.
# %run -i {pathL}/test02.py

def divisores(n):
    l = []
    for i in range(1, n):
        if n % i == 0:
            l.append(i)
    return l

def numeros_abundantes(n):
    divs = divisores(n)
    suma_divisores = sum(divs)
    if suma_divisores > n:
        return True
    else:
        return False

valor = int(input('Ingrese un número entero: '))
es_abundante = numeros_abundantes(valor)
print(f'El número {valor} es abundante: {es_abundante}')

# Commented out IPython magic to ensure Python compatibility.
# %run -i {pathL}/test03.py

def divisores(n):
    l = []
    for i in range(1, n):
        if n % i == 0:
            l.append(i)
    return l

def es_semiperfecto(n):
    divs = divisores(n)
    posibles_sumas = [False] * (n + 1)
    posibles_sumas[0] = True

    for divisor in divs:
        for i in range(n, divisor - 1, -1):
            if posibles_sumas[i - divisor]:
                posibles_sumas[i] = True

    return posibles_sumas[n]

valor = int(input('Ingrese un número entero: '))
es_semiperfecto = es_semiperfecto(valor)
print(f'El número {valor} es semiperfecto: {es_semiperfecto}')

# Commented out IPython magic to ensure Python compatibility.
# %run -i {pathL}/test04.py

def divisores(n):
    l = []
    for i in range(1, n):
        if n % i == 0:
            l.append(i)
    return l

def numeros_perfectos(n):
    divs = divisores(n)
    suma_divisores = sum(divs)
    if suma_divisores == n:
        return True
    else:
        return False

valor = int(input('Ingrese un número entero: '))
es_perfecto = numeros_perfectos(valor)
print(f'El número {valor} es perfecto: {es_perfecto}')

# Commented out IPython magic to ensure Python compatibility.
# %run -i {pathL}/test05.py

def divisores(n):
    l = []
    for i in range(1, n+1):
        if n % i == 0:
            l.append(i)
    return l

def numeros_primos(n):
    divs = divisores(n)
    suma_divisores = sum(divs)
    if suma_divisores > n+1:
        return False
    else:
        return True

valor = int(input('ingrese un número entero: '))
es_primo = numeros_primos(valor)
print(f'{valor} es primo: {es_primo}')

# Commented out IPython magic to ensure Python compatibility.
# %run -i {pathL}/test06.py

"""
7. Diseñar un programa en el que entrado dos números `a`  y `b` retorne una variable booleana **True** o **false**.

  [Números amigos](https://es.wikipedia.org/wiki/N%C3%BAmeros_amigos) `a` y `b` tales que a es la suma de los divisores propios de `b` y viceversa.
    La rutina se debera llamar numeros_amigos




P2. Retornar los 10 primeros pares de numeros perfectos, semiperfectos, amigos

"""

def suma_divisores_propios(n):
    suma = 0
    for i in range(1, n):
        if n % i == 0:
            suma += i
    return suma

def numeros_amigos(a, b):
    return suma_divisores_propios(a) == b and suma_divisores_propios(b) == a


a = int(input('ingrese un valor entero: '))
b = int(input('ingrese un segundo valor entero: '))
resultado = numeros_amigos(a, b)
print(resultado)

# Commented out IPython magic to ensure Python compatibility.
# %run -i {pathL}/test07.py

"""3. Determine si un número `n` entero ingresado por el usuario es un [palíndromo](https://en.wikipedia.org/wiki/Palindromic_number), (Retorne `True` en caso afirmativo y `False` en caso contrario)

```python


    >>> palindromo(3333333)
        True

    >>> palindromo(2323)
        True
        
    >>> palindromo(1111349111111)
        False
```



"""

def es_palindromo(n):
    return str(n) == str(n)[::-1]

n = int(input("Ingresa un número: "))
print(es_palindromo(n))

"""8 Construir un programa en el que  entrado un arreglo de números se  ordenen de forma ascendente, Ver algoritmo
[Quicksort](https://es.wikipedia.org/wiki/Quicksort).


```python


<<< v = [22, 32, 42, 12, 22, 31, 41, 11, 12, 232, 24, 12, 22]
<<< def quicksort(v):

<<<     return v
<<< w = print(quicksort(v))
<<< [11, 12, 12, 12, 22, 22, 22, 24, 31, 32, 41, 42, 232]

```

Sólo para comprobar tu código,  puedes hacer uso del comando sort de python.
```python
<<< b = [22, 32, 42, 12, 22, 31, 41, 11, 12, 232, 24, 12, 22]

<<< print(b.sort())

<<< [11, 12, 12, 12, 22, 22, 22, 24, 31, 32, 41, 42, 232]
```
"""

def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivote = arr[len(arr) // 2]
    izquierda = [x for x in arr if x < pivote]
    centro = [x for x in arr if x == pivote]
    derecha = [x for x in arr if x > pivote]
    return quicksort(izquierda) + centro + quicksort(derecha)

arr = list(map(int, input("Ingresa una lista de números separados por comas: ").split(',')))
arr_ordenado = quicksort(arr)
print(arr_ordenado)